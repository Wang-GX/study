一.JMeter使用说明(可以通过Options -> Choose Language -> 中文)：
1. Test Plan(右键) -> Add -> Threads(Users) -> Thread Group
    Thread Properties：
        (1)Number of Threads(users)：模拟请求线程数
        (2)Ramp-up period(seconds)：请求总耗时(秒)
           如果Ramp-up period 设置为0秒， JMeter 将立即建立所有线程。
           假设Ramp-up period 设置成T秒，全部线程数设置成N个， JMeter 将每隔T/N秒建立一个线程，所有线程的建立时间总和为T秒。
        (3)Loop Count：循环次数
2. Thread Group(右键) -> Add -> Sampler -> Http Request
    设置请求协议、服务器名称或IP、端口号、请求方式、请求路径、编码(utf-8)

3. Http Request(右键) -> Add -> Listener -> Aggregate Report(汇总报告)

3. 点击绿色箭头运行

如果需要发送json数据：
    Http Request(右键) -> Config Element -> Http Header Manager -> Add：content-type:application/json



二. Nginx
1. Nginx可以通过命令行来启动，操作命令：
- 启动：start nginx.exe
- 停止：nginx.exe -s stop
- 重新加载：nginx.exe -s reload

2. 配置文件 TODO

redis命令参考：
http://redisdoc.com/


三.分布式锁
分布式锁1.0：
核心：SETNX key value：只在键key不存在的情况下，将键key的值设置为value。
问题1：线程抛出异常，delete代码无法执行，后续线程永远执行不成功
解决1：try-catch-finally，保证delete代码一定会执行

问题2：程序宕机，或者应用程序重启，此时如果delete代码还未执行，则redis中的key仍然存在
解决2：设置key超时时间

问题3：setnx和设置key超时时间这两步操作不是原子性的，可能会在中途被打断执行(如宕机)
解决3：使用：Boolean setIfAbsent(K var1, V var2, long var3, TimeUnit var5);
      代替：Boolean setIfAbsent(K var1, V var2);  +  Boolean expire(K key, long timeout, TimeUnit unit);
      由redis控制这两步的原子操作。

问题4：如果某个线程1加锁成功，但是由于某些原因执行时间超过锁设置的过期时间，此时锁过期自动释放。后续线程2仍然可以执行。
问题5：在问题4场景出现的基础上，如果线程2先执行结束，触发delete，此时线程1仍然没有执行结束，那么线程2释放的是线程1加的锁，此时无法保证执行的先后顺序。
       这两种情况在高并发的场景下可能导致锁"永久失效"。(当前线程设置的锁被前一个线程释放)
       如果每个线程在加锁时设置的value值都相同或者线程在解锁时只判断key而不去判断value是否是当前线程设置的value，那么可能会出现下面的情况：
       锁过期时间设置为5s，线程1执行了7s，在第5s时锁自动释放，此时线程2加锁成功，线程2执行过程中线程1执行结束，释放掉了线程2加的锁。此时线程2仍然在执行过程中，但是redis中已经没有锁了，此时线程3加锁成功。
       线程3执行过程中线程2执行结束，释放掉了线程3加的锁。此时线程3仍然在执行过程中，但是redis中已经没有锁了，此时线程4加锁成功。
       ....
       在高并发场景下，可能导致长时间出现同一时刻同时存在多个线程同时执行的情况。
解决5：为每个线程设置唯一标识(UUID)，加锁时作为value。释放锁时先去redis中判断是否是当前线程设置的value。从而保证某一个线程加的锁只能由当前线程释放，在释放之前，其他线程
TODO 方法在栈中执行，局部变量不共享
TODO 方法在栈中执行，局部变量不共享
解决4：无法精确地设置锁的超时时间。如果锁的超时时间设置较短，可能会出现问题4。但是如果锁的超时时间设置较长，那么一旦出现问题2，将会导致其他线程长时间无法执行。
       设置较短的超时时间，如3s，在线程1执行的同时开启一个新的线程执行定时任务，每隔1s去判断一下线程1设置的锁是否存在。
       如果存在则说明线程1还没有执行结束，重新设置key的超时时间(相当于延长)。
       如果不存在则说明线程1已结执行结束，结束定时任务。


分布式锁2.0
核心：Redisson框架
底层一系列的1ua脚本，lua脚本是原子代码块，由redis保证是原子执行的，执行过程中不会被其他redis命令打断。
问题：如果使用redis主从架构，主节点的键值会被同步到从节点。
      如果redis主节点宕机，当从节点被选取为新的主节点，如果此时锁还没有同步到从节点，那么后续线程仍然可以执行。


TODO 注意对比这两种加锁方式，还有一个很重要的区别：
使用原生的Redis加锁，如果加锁失败直接判定此次请求失败，那么在200个线程同时请求200个库存时，由于大量的线程请求失败，总库存最终一定是大于0的。
而使用Redisson加锁，由于是默认是自旋锁，如果加锁失败则线程会继续尝试直到加锁成功(自旋锁获取锁一定会成功)，那么在200个线程同时请求200个库存时，总库存最终一定是等于0的。
当然前者也可以设置为自旋锁，即加锁失败时重试，最终结果和后者是一致的。
