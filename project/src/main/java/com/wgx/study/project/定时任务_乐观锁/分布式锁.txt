
实现分布式锁：

    原子性：
        乐观锁和悲观锁是通过数据库自带的锁保证操作的原子性。
        Redis/Redisson是通过setnx保证操作的原子性。

    核心：
        (1)在同一时间只会有一个客户端能获取到锁，其它客户端无法同时获取。
        (2)避免死锁。

    实现方式：
    (1)基于数据库实现：乐观锁，悲观锁
    (2)基于Redis实现
    (3)基于ZooKeeper实现(暂无)

普通线程锁和分布式锁：

    (1) 普通锁(synchronized)：锁住操作公共资源的代码，阻止多个本地线程同时执行。线程执行前先尝试进行获取锁的操作，如果能够拿到锁则执行，否则阻塞。锁的颗粒度最小为行。
    注意：锁必须唯一

    (2) 分布式锁(借助一台Redis服务实现)：逻辑相同，阻止多个不同节点上的线程同时执行。此时为了保证锁唯一，需要借助第三方工具redis。
    线程执行前先尝试从Redis中进行获取锁的操作，如果能够拿到锁则执行，否则阻塞(通过标记来判断)。锁的颗粒度最小为行。
    需要确保：多个服务不能同时执行被锁住的同一段代码，以及必须设置锁的超时时间，到时间自动释放，保证不会造成死锁。

    本地的多个定时任务应该是由不同的线程控制的，理论上是同时执行的，所以可以用来测试分布式锁

    【注意】数据库的行锁只能锁住一行数据记录的update，但是同步锁锁住的是一段代码的操作，这一段代码里可能不止包含一条操作数据库的SQL语句。前者的颗粒度更小，触发条件更苛刻，也就是说：
    行锁：两个线程不能同时执行一条对同一行数据记录的update操作
    同步锁：两个线程不能同时执行一段被锁住的代码

    (3) 实现思路：
    步骤：(左侧为本地线程锁，右侧为分布式锁)
    1. 当前线程尝试获取锁(自动)---------------->当前线程先到Redis中判断锁是否存在，如果存在则表示其他线程正在执行同步代码块中的内容，则当前线程阻塞，如果不存在则表示没有其他线程正在执行同步代码块中的代码，当前线程可以执行同步代码块中的代码。
    2. 当前线程进入同步代码块时锁住这段代码(自动)---------------->当前线程进入同步代码块时在Redis中设置一个锁标记(手动)，如：key：lock value：isLock，表示添加锁。
    3. 当前线程出同步代码块时释放锁(自动)---------------->线程出同步代码块时删除Redis中的锁标记，表示释放锁。

    关键点：
    1. 锁唯一：在Redis中设置唯一key(锁)
    2. 防止死锁：必须设置锁的自动失效时间，防止某个线程一直持有锁导致死锁(key设置后如果达到这个时间则自动删除，此时锁为非正常释放(某个线程执行完毕后手动删除该key为正常释放))。


    个人理解：
    锁就是一个标记，这个标记对于操作它的线程必须是可见并且唯一的。
    在单机应用中，由于只有一个JVM进程，而堆是线程共享区，所以每个线程共享堆中的对象以及对象上的标记。因此可以通过操作任意一个唯一对象上的标记，来实现多个线程之间的同步。
    可以这样认为，每个对象上的标记初始值为0。当有线程进入同步代码块时，JVM将这个标记的值置为1，此时其他线程都不能进入同步代码块。当这个线程执行完毕出同步代码块时，JVM将这个标记的值置为0，此时其他线程可以进入同步代码块。
    而在分布式环境下，存在多个JVM进程，也就是多个堆内存。此时为了保证标记对所有线程可见且唯一，需要借助第三方工具，如Redis。将唯一的key是否存在作为这个标记的值。
