## MySQL事务的隔离级别实现原理

### 1. 基于InnoDB的行级锁(索引)

#### 共享读锁(S)：读取时不会默认加读锁，多个事务之间的S锁不会阻塞。

#### 排他写锁(X)：更新时默认加写锁，不同事务之间的S锁和X锁会阻塞，但是相同事务的S锁和X锁不会阻塞。

由于更新操作时默认加写锁，所以避免了丢失更新的问题。事务的隔离级别即是通过读写锁+MVCC实现的

加锁方式：

lock in share mode;

for update;

事务提交时自动释放当前事务加的所有锁

### 2. 并发问题：

(1) 丢失更新：通过写锁机制解决

(2) 脏读：事务A读到了事务B未提交的数据

(3) 不可重复读：事务A读到了不同的数据内容

(4)幻读：事务A读到了不同的数据行数

### 3. 事务的隔离级别：

(1)读未提交：写数据时加X锁，写完立即释放。读数据时不加锁，所以可以读取到未提交的数据。解决了丢失更新的问题，产生了脏读。

(2)读已提交：写数据时加X锁，事务提交时释放，读数据时加S锁，读完立即释放，其他事务的读取操作将会被阻塞，解决了脏读。

(3)可重复读：写数据时加X锁，事务提交时释放，读数据时加S锁，事务提交时释放。即事务一旦进行了读取，直至事务提交之前，其他事务的更新操作将会被阻塞，解决了不可重复读。

(4)串行化：写数据时为整张表中的所有数据加X锁，事务提交时释放，读数据时为整张表中的所有数据加S锁，事务提交时释放。无论是读还是写，由于锁住了整张表，所以其他事务无法向表中插入数据，解决了幻读。

如果使用上述的实现方式，读已提交和可重复读由于在读取数据时加了读锁，显然会产生严重的读写阻塞问题。所以MySQL并没有采取上述方式，而是使用了MVCC对这两种隔离级别进行了实现。读取数据时并没有加读锁，【而是基于undo log通过当前读和快照读实现的。】

读提交：写数据时加X锁，事务提交时释放，读数据时读取的是最新的提交，即当前读。

可重复读：写数据时加X锁，事务提交时释放，读数据时基于版本链读取的是快照，即快照读。但是由于更新操作是当前读，即读取的是最新的提交，所以仍然存在幻读问题。例如事务A读取了user表的全部数据(max id= 10)，此时事务B向user表中插入了一条数据(id = 11)，事务A再次进行读取，由于版本链的存在，事务A读取到的是快照，和之前读取到的一致(max id= 10)。但是当事务A试图向user表中插入id为11的数据时，发现该数据已经存在了，即产生了幻读。

版本链：













