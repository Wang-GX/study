
https://www.cnblogs.com/jimmyhe/p/11013551.html
https://www.cnblogs.com/wade-luffy/p/8686883.html#_label6
https://blog.csdn.net/qq_38538733/article/details/88902979
https://www.jianshu.com/p/47e6b959a66e

MySQL存储引擎：
MyISAM、InnoDB

表级锁:开销小，加锁快;不会出现死锁;锁定粒度大，发生锁冲突的概率最高，并发度最低。
行级锁:开销大，加锁慢;会出现死锁;锁定粒度最小,发生锁冲突的概率最低，并发度也最高。

MyISAM(偏读)：
不支持事务
只支持表锁，MySQL的表级锁有两种模式:表共享读锁和表独占写锁。
执行查询语句时会对涉及到的表加读锁，执行更新语句时会对涉及到的表加写锁。
一旦数据表被加上读锁，其他请求可以对该表再次增加读锁，但是不能增加写锁。
    当一个进程在读数据时(加读锁)，其他进程也可以读，但是不能写。
一旦数据表被加上写锁，其他请求无法再对该表增加任何锁(读锁或写锁)。
    当一个进程在写数据时(加写锁)，其他进程不能执行任何读或写操作。
如果一个进程请求MyISAM表的表锁，同时另一个进程请求同一张表的读锁。默认情况下，MySQL会本着写锁优先的原则。
MyISAM的读写锁调度是写优先，这也是MyISAM不适合做以写为主的引擎。因为写锁后，其他线程不能做任何操作，大量的更新操作会使查询很难得到锁，从而造成永远阻塞。

InnoDB：
支持事务
默认情况下,数据库处于自动提交模式。每一条语句处于一个单独的事务中,在这条语句执行完毕时，如果执行成功则隐式的提交事务，如果执行失败则隐式的回滚事务。
支持行锁以及表锁，默认情况下加行锁。
执行查询语句时不会加任何锁(一致性非锁定读，可以手动加S锁或者X锁)，除非显示调用(这也导致了在并发请求下存在脏读、不可重复读、幻读的问题。事务的四种隔离级别正是在此基础上产生的)，执行更新语句时会对更新的行加写锁。
行锁的实现要求执行的SQL语句必须走索引(InnoDB的行锁是通过给索引加锁实现的)，否则会加表锁。通过索引可以快速到定位到数据，否则会进行全表扫描，所以会自动锁住整张表。
TODO InnoDB的表锁和MyISAM的表锁最好不要理解为一种锁

行共享读锁：
一旦索引被加上读锁，其他请求可以对该索引再次增加读锁，但是不能增加写锁。
    当一个事务对某几行加读锁时，其他事务可以读，但是不能写。
    上共享读锁的写法：lock in share mode
    例如：select * from table where id > 60 lock in share mode；
行排他写锁：
一旦索引被加上写锁，其他事务无法再在对该表增加任何锁(读锁或写锁)。
    当一个事务对某几行加写锁时，其他事务可以读，但是不能写。
    上排它锁的写法：for update
    例如：select * from table where id > 60 for update；

事务的隔离级别：
(1)读提交：一个事务只能读取到另一个事务已经提交的数据。
(2)可重复读(MySQL默认隔离级别)：
在可重复读中，该sql第一次读取到数据后，就将这些数据加锁（悲观锁），其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。















MySQL中InnoDB引擎的加锁机制


1.
数据库遵循的是两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段（所以叫两段锁）
加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁（共享锁，其它事务可以继续加共享锁，但不能加排它锁），在进行写操作之前要申请并获得X锁（排它锁，其它事务不能再获得任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。
解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。


理论基础：
1、S锁(共享锁)：
2、X锁(排它锁)：更新时自动加X锁，用来解决丢失修改的问题
3、MVCC：读提交、可重复读
    优势为读不加锁，读写不冲突
    MVCC实现了保证可重复读并在读数据的时候不需要加锁操作
    所谓的MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的事务在执行普通的SEELCT操作时访问记录的版本链的过程，
    这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。READ COMMITTD、REPEATABLE READ这两个隔离级别的一个很大不同就是生成ReadView的时机不同，
    READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复这个ReadView就好了。

事务	加锁/解锁处理
begin；
insert into test .....	加insert对应的锁
update test set...	加update对应的锁
delete from test ....	加delete对应的锁
commit;	事务提交时，同时释放insert、update、delete对应的锁



2.
事务中的加锁方式

事务的四种隔离级别
在数据库操作中，为了有效保证并发读取数据的正确性，提出的事务隔离级别。【我们的数据库锁，也是为了构建这些隔离级别存在的】。

隔离级别	                    脏读（Dirty Read）	不可重复读（NonRepeatable Read）	幻读（Phantom Read）
未提交读（Read uncommitted）	可能	            可能	                            可能
已提交读（Read committed）	    不可能	            可能	                            可能
可重复读（Repeatable read）	    不可能	            不可能	                            可能
可串行化（Serializable ）	    不可能	            不可能	                            不可能
未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据
提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)
可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读
串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞

InnoDB会根据事务的隔离级别自动加锁

3.
MySQL中锁的种类
MySQL中锁的种类很多，有常见的表锁和行锁，也有新加入的Metadata Lock等等,
表锁是对一整张表加锁，虽然可分为读锁和写锁，但毕竟是锁住整张表，会导致并发能力下降，一般是做ddl处理时使用。
行锁则是锁住数据行，这种加锁方法比较复杂，但是由于只锁住有限的数据，对于其它数据不加限制，所以并发能力强，MySQL一般都是用行锁来处理并发事务。

4.

+----+--------------+------------+
| id | class_name   | teacher_id |
+----+--------------+------------+
|  1 | 初三一班     |          1 |
|  2 | 初二一班     |          2 |
|  3 | 初二二班     |          2 |
+----+--------------+------------+

(1)Read Uncommitted(读未提交)这种级别，数据库一般都不会用。
   写数据时加上X锁，直到事务结束，读的时候不加锁。
   因为读的时候不加锁，所以事务B可以读取到事务A修改但未提交(加X锁)的数据。
(2)Read Committed（读已提交）：在RC级别中，数据的读取都是不加锁的，但是数据的写入、修改和删除是需要加锁的。
   写数据的时候加上X锁，直到事务结束，读的时候加上S锁，读完数据立刻释放。
   因为读的时候加S锁，所以事务B无法读取到事务A修改但未提交(加X锁)的数据。事务A提交后，X锁释放，此时事务B可以读取，解决了脏读。
   因为读完数据后立刻释放S锁，所以事务A读完后事务B可以更新该数据(加X锁)，此时如果事务A再次读取则会读到和之前不同的结果，即出现了不可重复读。
事务A	                                                                        事务B
begin;	                                                                        begin;
update class_teacher set class_name='初三二班' where teacher_id=1;	            update class_teacher set class_name='初三三班' where teacher_id=1;
 	                                                                            ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
commit;
为了防止并发过程中的修改冲突，事务A中MySQL给teacher_id=1的数据行加锁，并一直不commit（释放锁），那么事务B也就一直拿不到该行锁，wait直到超时。
这时我们要注意到，teacher_id是有索引的，如果是没有索引的class_name呢？update class_teacher set teacher_id=3 where class_name = '初三一班';
那么MySQL会给整张表的所有数据行的加行锁。这里听起来有点不可思议，但是当sql运行的过程中，MySQL并不知道哪些数据行是 class_name = '初三一班'的（没有索引嘛），如果一个条件无法通过索引快速过滤，存储引擎层面就会将所有记录加锁后返回，再由MySQL Server层进行过滤。
但在实际使用过程当中，MySQL做了一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录释放锁 (违背了二段锁协议的约束)。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。
这种情况同样适用于MySQL的默认隔离级别RR。所以对一个数据量很大的表做批量修改的时候，如果无法使用相应的索引，MySQL Server过滤数据的的时候特别慢，就会出现虽然没有修改某些行的数据，但是它们还是被锁住了的现象。

(3)Repeatable Read（可重读）：这是MySQL中InnoDB默认的隔离级别。
   写数据的时候加上X锁，直到事务结束，读数据的时候加S锁，也是直到事务结束。
   因为读的时候加S锁，所以事务B无法读取到事务A修改但未提交(加X锁)的数据。事务A提交后，X锁释放，此时事务B可以读取，解决了脏读。
   因为读完数据后不会立刻释放S锁，所以事务A读完后事务B不可以更新该数据(加X锁失败)，解决了不可重复读。
   对于新增的数据，由于加了X锁，所以事务A无法读到该数据(加S锁失败)，出现了幻读。
   理论上是可行的，但是MySQL为了避免对读操作加S锁，并且得持续到整个事务结束。没有使用上面的实现方式，而是使用了MVCC(多版本并发控制)，实现了可重复读，并在在读数据的时候不需要加S锁，即事务A读数据时，事务B可以更新该数据，这个更新对事务A是不可见的。
   MVCC：
   MVCC使得大部分支持行锁的事务引擎，不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来，只需要很小的开销,就可以实现非锁定读，从而大大提高数据库系统的并发性能。
   InnoDB 的 MVCC 是通过在每行记录后面保存 2 个隐藏列实现的。一个保存行的创建时间，一个保存行的删除时间。
   当然存储的不是时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务版本号是事务开始时刻的系统版本号。
   在可重复读的隔离级别下，当第一个Read操作发生的时候，Read view就会建立。 在Read Committed隔离级别下，每次发出Read操作，都会建立新的Read view
   对于可重复读，查询只承认在事务启动前就已经提交完成的数据；
   对于读提交，查询只承认在语句启动前就已经提交完成的数据；
   MVCC 只在 read committed 和 repeatable read 2 个隔离级别工作，其他隔离级别并没有使用这种机制。read uncommitted 总是读取最新的数据行，而不是符合当前事务版本的数据行，seriablizable 会对所有读取的行都加锁。


事务A	                                                                        事务B	                                                                        事务C
begin;                                                                          begin;                                                                          begin;

select id,class_name,teacher_id from class_teacher where teacher_id=1;

id	class_name	teacher_id
1	初三二班	1
2	初三一班	1

                                                                                update class_teacher set class_name='初三三班' where id=1;
                                                                                commit;



 	 	                                                                                                                                                        insert into class_teacher values (null,'初三三班',1);
 	 	                                                                                                                                                        commit;
select id,class_name,teacher_id from class_teacher where teacher_id=1;

id	class_name	teacher_id
1	初三二班	1
2	初三一班	1

没有读到事务B修改的数据，和第一次sql读取的一样，是可重复读的。
没有读到事务C新添加的数据。

insert into class_teacher values (4,'初三三班',1);

Duplicate entry '4' for key 'PRIMARY'
【幻读：事务在插入已经检查过不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测获取到的数据如同鬼影一般】
TODO 可重复读的幻读问题是在事务没有提交前，两次读取读到的数据是一致的。事务B新增了一条数据，事务A是读不到的。但是这条新增的数据在数据库中是真实存在的，
     可能在执行INSERT/UPDATE时遇到幻读现象。因为SELECT不加锁的快照读行为是无法限制其他事务对新增重合范围的数据的插入的。
commit;

在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。（错误，可以更新）
但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。
需要Serializable隔离级别，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。

(4)Serializable（串行）
   Serializable对所有读操作都加锁，读写发生冲突，不会使用MVCC


幻读的演示：
id  name
1	二年一班
2	二年二班
开启事务A和事务B

事务A(事务版本号1)                                   事务B(事务版本号2)
START TRANSACTION;                                   START TRANSACTION;
select * from class;生成读快照(只能读到【1<=,null/>1】)
       ↓
id  name
1	二年一班
2	二年二班                                         insert into class values(3,'二年三班');(加X锁)【2,null】
                                                     commit;(释放X锁)

select * from class;//快照读
       ↓                                            //事务A查询不到事务B新增的id为3的数据，因为事务A的查询只承认在事务A开始前就已经提交完成的数据
id  name
1	二年一班
2	二年二班

update class set name = '二年四班';//当前读【旧数据2,1】【新数据1,null】      //事务A更新了事务B新增的数据，此时id为3的数据对于事务A而言从不可见变为可见，因为事务A更新了这条数据，这条数据的当前系统版本(由事务A更新)对事务A而言是可见的
select * from class;                                 //根据select规则(可见性)，事务A可以读取到id为3的这条数据了
       ↓
id  name
1	二年四班                                         //事务A第一次查询到2条数据，第二次查询到3条数据，出现了幻读问题
2	二年四班
3   二年四班

在MySQL可重复读的隔离级别中并不是完全解决了幻读的问题，而是解决了读数据情况下的幻读问题。而对于修改的操作依旧存在幻读问题(需要理解快照读和当前读)，就是说MVCC对于幻读的解决是不彻底的。

通过MVCC机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，不是数据库最新的数据。这种读取历史数据的方式，我们叫它快照读 (snapshot read)，而读取数据库最新版本数据的方式，叫当前读 (current read)。

当执行select操作是innodb默认会执行快照读，会记录下这次select后的结果，之后select的时候就会返回这次快照的数据，即使其他事务提交了不会影响当前select的数据，这就实现了可重复读了。
对于会对数据修改的操作(update、insert、delete)都是采用当前读的模式。在执行这几个操作时会读取最新的记录，即使是别的事务提交的数据也可以查询到。

InnoDB的MVCC，通过在每行记录后面保存两个隐藏的列来实现：行创建时的版本号 & 行删除(过期)版本号。
select时读取数据的规则为：创建版本号<=当前事务版本号，删除版本号为空或>当前事务版本号。
insert操作。
insert时将当前的系统版本号赋值给创建版本号字段。
delete操作。
删除时将当前的系统版本号赋值给删除版本号字段(标识该行数据在那一个事物中会被删除)。
update操作。
delete + insert操作的组合。delete的行(旧的数据行)对应delete操作，insert的行(新的数据行)对应insert操作

//TODO 网上流传很多的，【隐藏的两列，创建版本号和删除版本号】不完全正确(参考下面的地址，正确性较高)
https://blog.csdn.net/c5113620/article/details/103646595

如何解决幻读(待)
很明显可重复读的隔离级别没有办法彻底的解决幻读的问题，如果我们的项目中需要解决幻读的话也有两个办法：

使用串行化读的隔离级别
MVCC+next-key locks：next-key locks由record locks(索引加锁) 和 gap locks(间隙锁，每次锁住的不光是需要使用的数据，还会锁住这些数据附近的数据)
实际上很多的项目中是不会使用到上面的两种方法的，串行化读的性能太差，而且其实幻读很多时候是我们完全可以接受的。


串行化：
读写操作都会对数据加锁，可能会导致大量的请求超时现象发生
读与读不冲突，因为都加S锁
读与写必然冲突，因为S锁和X锁冲突



MYSQL 事务处理主要有两种方法：
1、用 BEGIN, ROLLBACK, COMMIT来实现

BEGIN 开始一个事务
ROLLBACK 事务回滚
COMMIT 事务确认
2、直接用 SET 来改变 MySQL 的自动提交模式:

SET AUTOCOMMIT=0 禁止自动提交
SET AUTOCOMMIT=1 开启自动提交