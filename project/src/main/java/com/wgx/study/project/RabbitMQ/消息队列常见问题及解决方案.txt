RabbitMQ常见问题：
1.五种消息模型
https://blog.csdn.net/weixin_43365369/article/details/94197758
(1)基本消息模型：一个生产者、一个队列、一个消费者监听
(2)work消息模型：一个生产者、一个队列、多个消费者监听(注意：队列中的一条消息只能被监听该队列的一个消费者获取)
(3)订阅模型Fanout(广播)：一个生产者、一个交换机、多个队列绑定交换机、消费者监听各自的队列
(4)订阅模型Direct(路由)：一个生产者，发送消息时指定routingKey、一个交换机、多个队列绑定交换机时指定各自的routingKey、消费者监听各自的队列
(5)订阅模型Topic(通配符)：在(4)的基础上，队列绑定交换机时routingKey支持通配符

2.如何避免消息重复消费
    保证接口的幂等性，这个要结合实际的业务场景进行处理。
(1)业务场景：
    例如用户下单成功后需要去一个活动页面给他的推广者加GMV(销售总额)，最终根据他的GMV去给他发放对应奖励，这是电商活动很常见的玩法。
    这样的活动页面基本上都是用异步去加的，不然你想，你一个用户下一单就给他加一下，那就意味着对那张表就要操作一下，你考虑下双十一当天多少次对这个表的操作，这数据库或者缓存都顶不住吧。
    下单成功时就要发送个消息出去，此时可能有多个服务在同时监听这条消息(积分系统、优惠券系统、库存系统...)。一般消息队列的使用，都是有重试机制的，下游的业务抛出异常时会要求你重新发送一次(PS：这里说的是重发消息，而不是将消息丢回队列。)。
    但是对于其他服务而言，上一条消息可能是已经消费成功的，所以一旦重发，就相当于收到了重复的消息。例如积分系统处理失败了，要求重新发送消息，最终可能导致积分是正确的，但是优惠券扣除了两次。GMV给他加了两次。
    真实的情况其实重试是很正常的，服务的网络抖动，开发人员代码Bug，还有数据问题等都可能处理失败要求重发的。
(2)解决方案：
    接口幂等：通俗地讲，就是同样的参数去调用这个接口，无论调用多少次结果都相同
    一般接口的幂等，需要分场景去考虑，看是强校验还是弱校验。比如跟金钱相关的场景那就很关键，就做强校验，不是很重要的场景就做弱校验。
    强校验(磁盘保存)：
        例如每次加钱之后都去流水表中新增一条数据，并且将这两步操作放在同一个事务当中，要么同时成功，要么同时失败。
        每次消息过来都要拿着订单号+业务场景唯一标识去流水表查，看看有没有这条流水，有就直接return不要走下面的流程了，没有就执行后面的逻辑。
        之所以用流水表，是因为涉及到金钱这样的活动，有啥问题后面也可以去流水表对账，还有就是帮助开发人员定位问题。
    弱校验(使用缓存)：
        例如每次发送短信之后可以把这个id+业务场景唯一标识作为redis的key，放到缓存中，失效时间由业务场景决定。
        每次消息消费前先去redis中查是否存在这个key，如果存在就认为已经消费过了，如果不存在就认为还没有被消费过。
        弱校验的场景，就算消息丢了也无所谓(磁盘上也没有保留任何记录可以追溯)，无关痛痒。

3.如何避免消息丢失
https://www.jianshu.com/p/8ed16edc73e4?from=timeline&isappinstalled=0
    丢失数据的场景：
        (1)生产者弄丢了数据：生产者将数据发送到RabbitMQ的时候，可能在传输过程中因为网络等问题而将数据弄丢了。
           解决方案：生产者确认(confirm)：生产者发送消息后，等待RabbitMQ的ACK，如果没有收到或者收到失败信息，则重试。
        (2)RabbitMQ弄丢了数据：如果没有开启RabbitMQ的持久化，那么RabbitMQ一旦重启，队列中的数据就会丢失。
           解决方案：声明交换机和队列时将其设置为持久化的，生产者发送消息时持久化消息到磁盘上。这样就算RabbitMQ挂了，恢复之后也会自动从磁盘中读取之前存储的数据。
        (3)消费这弄丢了数据：主要是因为消费者消费时，刚消费到，还没有处理，结果消费者就挂了，这样你重启之后，rabbitmq就认为你已经消费过了，然后就丢了数据。
           解决方案：首先关闭RabbitMQ的自动ACK，确保消息处理完成之后，再进行手动ACK。

4.如何保证消息按照顺序进行消费
    顺序错乱的场景：一个队列，存在三个消费者。生产者向队列中发了三个消息，对应的操作分别为：增、改、删。虽然消费者从MQ里面读取数据是有序的，但是每个消费者的执行时间是不固定的，无法保证先读到消息的消费者一定先完成操作。
    例如消费者1先获取了增操作的消息，消费者2后获取了改操作的消息，消费者3后获取了删操作的消息，但是执行完成的先后顺序为消费者3 > 消费者2 > 消费者1。这样就会出现消息并没有按照顺序执行，造成数据顺序错误。
    解决方案：一个队列只对应一个消费者，因为消费者从MQ里面读取数据是有序的，所以保证了消息是按照先后顺序进行消费的。