https://blog.csdn.net/weixin_43365369/article/details/94197758
消息队列的消息重复消费
(1)业务场景：
    例如用户下单成功后需要去一个活动页面给他的推广者加GMV(销售总额)，最终根据他的GMV去给他发放对应奖励，这是电商活动很常见的玩法。
    这样的活动页面基本上都是用异步去加的，不然你想，你一个用户下一单就给他加一下，那就意味着对那张表就要操作一下，你考虑下双十一当天多少次对这个表的操作，这数据库或者缓存都顶不住吧。
    下单成功时就要发送个消息出去，此时可能有多个服务在同时监听这条消息(积分系统、优惠券系统、库存系统...)。一般消息队列的使用，都是有重试机制的，下游的业务抛出异常时会要求你重新发送一次。
    但是对于其他服务而言，上一条消息可能是已经消费成功的，所以一旦重发，就相当于收到了重复的消息。例如积分系统处理失败了，要求重新发送消息，最终可能导致积分是正确的，但是优惠券扣除了两次。GMV给他加了两次。
    真实的情况其实重试是很正常的，服务的网络抖动，开发人员代码Bug，还有数据问题等都可能处理失败要求重发的。
(2)解决方案：
    接口幂等：通俗地讲，就是同样的参数去调用这个接口，无论调用多少次结果都相同
    一般接口的幂等，需要分场景去考虑，看是强校验还是弱校验。比如跟金钱相关的场景那就很关键，就做强校验，不是很重要的场景就做弱校验。
    强校验(磁盘保存)：
        例如每次加钱之后都去流水表中新增一条数据，并且将这两步操作放在同一个事务当中，要么同时成功，要么同时失败。
        每次消息过来都要拿着订单号+业务场景唯一标识（比如天猫双十一活动）去流水表查，看看有没有这条流水，有就直接return不要走下面的流程了，没有就执行后面的逻辑。
        之所以用流水表，是因为涉及到金钱这样的活动，有啥问题后面也可以去流水表对账，还有就是帮助开发人员定位问题。
    弱校验(可以使用缓存)：
        例如每次发送短信之后可以把这个id+业务场景唯一标识作为redis的key，放到缓存中，失效时间由业务场景决定(例如双十一活动结束时统一失效)。
        每次消息消费前先去redis中查是否存在这个key，如果存在就认为已经消费过了，如果不存在就认为还没有被消费过。
        弱校验的场景，就算消息丢了也无所谓(磁盘上也没有保留任何记录可以追溯)，无关痛痒。